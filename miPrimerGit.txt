Hola! Este documento recoge informaciÃ³n para que puedas crear un repositorio Local (en tu PC)
y lo subas a GitHub, puedas editarlo tÃº y otros usuarios de GitHub.

Te explico todo paso a paso y con opciones. 

Espero que te sea de ayuda. â˜ºï¸



âœï¸ EMPEZAMOS!!

1â©â© Â¿Debo crear una clave SSH? Esto es IMPORTANTE.

RecomendaciÃ³n: sÃ­ si vas a trabajar desde la terminal (Linux / macOS / Git Bash Windows) 
o si quieres evitar tener que introducir tokens/contraseÃ±as cada vez.

Ventajas SSH: autentificaciÃ³n sin escribir token cada push, es seguro y ampliamente usado.

Alternativa: HTTPS + Personal Access Token (PAT) o usar GitHub Desktop / GitHub CLI. 
Si prefieres PAT, GitHub ahora recomienda los fine-grained tokens cuando sea posible. 


2â©â© CÃ³mo crear una clave SSH (opciones y comandos)

Nota: usa ed25519 cuando tu sistema lo soporte (actualmente recomendado). 
Si no, rsa -b 4096 es la alternativa.

--------------------------------
Comprobar si ya tienes una clave:

`ls -al ~/.ssh`
--------------------------------


--------------------------------
Generar (macOS / Linux / Git Bash):

`ssh-keygen -t ed25519 -C "tu-email@example.com"`
--------------------------------


--------------------------------
Arrancar el agente SSH y aÃ±adir la clave:

# arrancar ssh-agent:
`eval "$(ssh-agent -s)"`

# aÃ±adir la clave al agente:
`ssh-add ~/.ssh/id_ed25519`
--------------------------------


--------------------------------
Copiar la clave pÃºblica al portapapeles:

macOS: pbcopy < ~/.ssh/id_ed25519.pub

Linux: xclip -sel clip < ~/.ssh/id_ed25519.pub (si tienes xclip) 
ğŸ‘€ o tambiÃ©n: cat ~/.ssh/id_ed25519.pub y copiar a mano

Windows (Git Bash): clip < ~/.ssh/id_ed25519.pub
--------------------------------


--------------------------------
AÃ±adir la clave a GitHub

En GitHub: esquina superior derecha â†’ Settings â†’ SSH and GPG keys â†’ New SSH key â†’ pega tu clave pÃºblica y guarda. 
--------------------------------


--------------------------------
Probar conexiÃ³n

`ssh -T git@github.com`
--------------------------------

Si todo va bien verÃ¡s un mensaje de bienvenida.
-----------------------------------------------
ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿




3â©â© Crear el repositorio (opciones que verÃ¡s en la interfaz web)

Ir a GitHub y pulsar + â†’ New repository (o https://github.com/new). 



------------------------------------------------------
Pasos / opciones que te aparecerÃ¡n y decisiÃ³n a tomar:
------------------------------------------------------

ğŸŒ¿ Owner: eliges tu cuenta personal o una organizaciÃ³n (si perteneces a alguna). 


ğŸŒ¿ Repository name: nombre corto y memorable.

ğŸŒ¿ Description (opcional): una lÃ­nea que describa el propÃ³sito.

ğŸŒ¿ Visibility: Public (cualquiera lo puede ver / forkear) o Private 
(solo quien tÃº autorices puede ver). Nota: tÃº puedes hacer pÃºblico 
y seguir siendo el Ãºnico con control administrativo (no confundir ver vs controlar). 

ğŸŒ¿ Initialize this repository with:

ğŸŒ¿ README (crea el primer commit y muestra la pÃ¡gina principal)

ğŸŒ¿ .gitignore (elige plantilla para tu lenguaje)

ğŸŒ¿ LICENSE (elige licencia si quieres permitir usos concretos)
Si ya tienes un repo local con commits, no marques â€œInitialize with READMEâ€ 
para evitar conflictos: en ese caso crea el repo vacÃ­o y aÃ±ade el remoto desde local (ver abajo). 

ğŸŒ¿ Create repository â†’ una vez creado GitHub te mostrarÃ¡ instrucciones (clone URL SSH y HTTPS).

------------------------------------------------------------------------------------------------
ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿

--------------------------------
1ï¸âƒ£ Crear la carpeta y el archivo
--------------------------------

ğŸŒ¿ Abre la terminal.

ğŸŒ¿ Crea una carpeta llamada "miPrimerRepositorio" y muÃ©vete dentro de ella:

`mkdir miPrimerRepositorio
cd miPrimerRepositorio`


ğŸŒ¿ Crea un archivo de texto llamado miPrimerGit.txt:

`echo "Â¡Hola, Git!" > miPrimerGit.txt`


âœï¸ Nota: Esto crea el archivo y escribe â€œÂ¡Hola, Git!â€ dentro de Ã©l.



ğŸŒ¿ Abre la carpeta en VS Code para visualizar el archivo:

code .
---------------------------------------------------------


------------------
2ï¸âƒ£ Configurar Git
------------------

ğŸŒ¿ Si es la primera vez que usas Git en este equipo, configura tu usuario y email:

`git config --global user.name "TuNombre"`
`git config --global user.email "tuemail@ejemplo.com"`

Esto le dice a Git quiÃ©n hace los cambios.
------------------------------------------


-------------------
3ï¸âƒ£ Inicializar Git
-------------------

ğŸŒ¿ Inicializa un repositorio Git dentro de la carpeta:

`git init`


ğŸŒ¿ Salida esperada:

`Initialized empty Git repository in /ruta/miPrimerRepositorio/.git/`


ğŸŒ¿ Ahora tu carpeta estÃ¡ lista para usar Git.
---------------------------------------------


------------------------------
4ï¸âƒ£ Ver el estado actual de Git
------------------------------

ğŸŒ¿ Usa git status para ver los cambios:

`git status`


ğŸŒ¿ Salida esperada:

`Untracked files:
  (use "git add <file>..." to include in what will be committed)
        miPrimerGit.txt`


Esto indica que Git ve el archivo pero aÃºn no lo estÃ¡ siguiendo.
-------------------------------------------------------------------


-----------------------------------------------------------
5ï¸âƒ£ Agregar el archivo al Ã¡rea de preparaciÃ³n (staging area):
-----------------------------------------------------------

`git add miPrimerGit.txt`


ğŸŒ¿ Verifica con git status:

`git status`


ğŸŒ¿ Salida esperada:

`Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   miPrimerGit.txt`


Ahora Git estÃ¡ listo para hacer commit de este archivo.
-------------------------------------------------------


--------------------------
6ï¸âƒ£ Hacer el primer commit
--------------------------

`git commit -m "Primer commit: agregamos miPrimerGit.txt"`


ğŸŒ¿ Salida esperada:

`[main (root-commit) 123abcd] Primer commit: agregamos miPrimerGit.txt
 1 file changed, 1 insertion(+)
 create mode 100644 miPrimerGit.txt`


ğŸ‰ Â¡Felicidades! Tu primer commit estÃ¡ hecho.



-------------------------------
7ï¸âƒ£ Ver el historial de commits
-------------------------------

ğŸŒ¿ Para ver un historial resumido:

 --------------------
|  git log --oneline |
 --------------------


ğŸŒ¿ Salida esperada:

 ---------------------------------------------------
|  123abcd Primer commit: agregamos miPrimerGit.txt |
 ---------------------------------------------------

Esto muestra todos los commits en lÃ­nea.
----------------------------------------

âœ… Resumen visual en VS Code:

ğŸŒ¿ La carpeta miPrimerRepositorio contiene miPrimerGit.txt.

ğŸŒ¿ git status ğŸŒ¿  muestra si hay cambios pendientes.

ğŸŒ¿ git add ğŸŒ¿ mueve archivos al staging area.

ğŸŒ¿ git commit ğŸŒ¿  guarda los cambios.

ğŸŒ¿ git log --oneline ğŸŒ¿  muestra los commits resumidos.

----------------------------------------------------

ğŸ›ï¸ Cada rama que creamos tiene que ser creada especÃ­ficamente 
para resolver un problema, para crear alguna funcionalidad nueva
o para un objetivo concreto.

-----------------------------------------------------------------------------


ğŸ‘ Vamos a ver cÃ³mo subir un archivo a un repositorio de GitHub, paso a paso, 
y te explico quÃ© hace cada comando de Git de forma clara y sencilla.

................................
ğŸ§© 1. Inicializar el repositorio
`git init`
................................

QuÃ© hace:
Crea un nuevo repositorio de Git en la carpeta actual.
Git empieza a â€œvigilarâ€ los archivos de esa carpeta para registrar los cambios que hagas.

ğŸ“˜ Ejemplo:
Si estÃ¡s en una carpeta llamada mi-proyecto, este comando crea una subcarpeta oculta .git 
que guarda toda la informaciÃ³n de versiones.

..........................................................
ğŸ“„ 2. AÃ±adir los archivos al Ã¡rea de preparaciÃ³n (staging)
`git add nombre_del_archivo`
..........................................................

O para agregar todos los archivos:
`git add .`

QuÃ© hace:
Le dice a Git quÃ© archivos quieres incluir en la prÃ³xima versiÃ³n (commit).
Piensa en esto como â€œmarcarâ€ los archivos que se van a guardar.

ğŸ“˜ Ejemplo:
git add index.html â†’ marca ese archivo.
git add . â†’ marca todos los archivos nuevos o modificados.

.................................................
ğŸ’¾ 3. Guardar los cambios en el repositorio local
`git commit -m "Mensaje descriptivo de los cambios que has realizado en dicho archivo"`
.................................................

QuÃ© hace:
Guarda una â€œfotoâ€ (snapshot) de los archivos aÃ±adidos.
El mensaje entre comillas describe los cambios realizados.

ğŸ“˜ Ejemplo:
`git commit -m "Agrego el archivo index.html con el diseÃ±o inicial"`

ğŸ§ Esto no sube nada a GitHub todavÃ­a, solo guarda el historial en tu computadora.

........................................................................
ğŸŒ 4. Conectar tu repositorio local con el de GitHub:
`git remote add origin https://github.com/usuario/nombre-repositorio.git`
........................................................................

QuÃ© hace:
Le dice a Git dÃ³nde estÃ¡ el repositorio remoto (en GitHub).
â€œoriginâ€ es solo un nombre corto para esa URL.

ğŸ“˜ Ejemplo:
`git remote add origin https://github.com/maria/mi-proyecto.git`

.......................................................
â¬†ï¸ 5. Subir los archivos al repositorio remoto (GitHub)
`git push -u origin main`
.......................................................

QuÃ© hace:
EnvÃ­a (sube) tus commits al repositorio remoto (GitHub).

ğŸ¥ origin â†’ el nombre del remoto que agregaste.

ğŸ¥ main â†’ la rama (branch) principal del proyecto.

ğŸ¥ El -u le dice a Git que recuerde esta conexiÃ³n, 
   para que la prÃ³xima vez puedas usar solo git push.

ğŸ“˜ Ejemplo:
`git push -u origin main`
Sube todos tus commits guardados a la rama principal en GitHub.

..............................................................
ğŸš€ 6. Actualizar tu repositorio local desde GitHub (opcional)
`git pull origin main`
..............................................................

QuÃ© hace:
Descarga los Ãºltimos cambios del repositorio remoto (GitHub) a tu copia local.
Ãštil si trabajas en equipo y alguien mÃ¡s subiÃ³ cambios.


ğŸ” Resumen rÃ¡pido

AcciÃ³n	                          Comando	                                    QuÃ© hace

Inicializar repositorio           `git init`	                                Empieza a usar Git en una carpeta.
Agregar archivos                  `git add .`	                                Marca los archivos a guardar.
Guardar cambios                   `git commit -m "mensaje"`	                  Crea una versiÃ³n local.
Conectar con GitHub               `git remote add origin URL-de-GitHub`	      Vincula tu carpeta local con GitHub.
Subir cambios  	                  `git push -u origin main`	                  Sube tus commits a GitHub.
Actualizar desde GitHub           `git pull origin main`	                    Descarga los cambios mÃ¡s recientes.
------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------

El pull request (a menudo abreviado como PR) es una de las partes mÃ¡s importantes 
del flujo de trabajo en GitHub (y otras plataformas como GitLab o Bitbucket).

Vamos a verlo de forma sencilla ğŸ‘‡

...........................
ğŸ§  Â¿QuÃ© es un pull request?
...........................

Un pull request (PR) es una solicitud para fusionar tus cambios (commits) de una rama en otra, 
normalmente de tu rama de trabajo hacia la rama principal (main o master) de un repositorio.


ğŸ‘‰ En otras palabras:

â€œOye, he hecho unos cambios en mi rama, Â¿pueden revisarlos y unirlos al proyecto principal?â€



ğŸ§© CuÃ¡ndo se usa:

Se usa principalmente cuando:

ğŸ¥ EstÃ¡s colaborando en equipo.

ğŸ¥ Quieres que otra persona revise tu cÃ³digo antes de integrarlo.

ğŸ¥ Quieres mantener el control y orden del proyecto (no fusionar cambios sin revisar).


.................................
âš™ï¸ Flujo tÃ­pico con pull request
.................................

Creas una rama para tus cambios:

`git checkout -b nueva-funcionalidad`

Esto separa tu trabajo del cÃ³digo principal.


Haces cambios y los subes:

`git add .`
`git commit -m "Agrego nueva funcionalidad X"`
`git push origin nueva-funcionalidad`


Abres un Pull Request en GitHub:

Vas al repositorio en GitHub.

VerÃ¡s un botÃ³n que dice â€œCompare & pull requestâ€.

Escribes una descripciÃ³n de lo que hiciste.

EnvÃ­as el PR.

El equipo revisa el cÃ³digo:
Pueden dejar comentarios, pedir cambios o aprobarlo.

Se hace el merge (fusiÃ³n):
Una vez aprobado, se combinan tus cambios con la rama principal:

`git merge nueva-funcionalidad`

.....................................................................................................
ğŸ’¬ En resumen

AcciÃ³n	                            QuÃ© hace
Pull Request	                      Pide que tus cambios se revisen y se unan al cÃ³digo principal
Objetivo	                          Revisar, discutir y aprobar cÃ³digo antes de fusionarlo
DÃ³nde                               Se hace	En GitHub (no en la terminal)
Beneficio	                          Mejora la calidad del cÃ³digo, evita errores y fomenta colaboraciÃ³n
.....................................................................................................


ğŸ’¡ AnalogÃ­a sencilla:

Imagina que tÃº escribes un capÃ­tulo nuevo para un libro del equipo.
Antes de que se publique, haces un pull request para que los demÃ¡s autores lo revisen, 
lo corrijan si es necesario, y finalmente lo integren al libro oficial ğŸ“–.


Ejemplo completo de flujo de trabajo con ramas y un pull request paso a paso 
(como lo harÃ­as tÃº desde la terminal hasta GitHub).

Vamos a hacer un ejemplo completo paso a paso de cÃ³mo trabajar con ramas y crear un Pull Request (PR) en GitHub.


Te voy a guiar como si fueras tÃº escribiendo en la terminal ğŸ–¥ï¸
(Este flujo es el mÃ¡s usado por equipos profesionales).

-------------
ğŸš€ Escenario:
-------------
Tienes un repositorio en GitHub llamado mi-proyecto.
Quieres agregar una nueva funciÃ³n o cambiar algo, pero sin romper el cÃ³digo principal.

AsÃ­ que trabajas en una rama nueva â†’ haces cambios â†’ los subes â†’ creas un pull request.


ğŸ§© Paso a paso:


1ï¸âƒ£ Clona el repositorio desde GitHub

Si aÃºn no lo tienes en tu computadora:

`git clone https://github.com/tu-usuario/mi-proyecto.git`

âœï¸ QuÃ© hace:
Descarga una copia del repositorio remoto (en GitHub) a tu mÃ¡quina local.


2ï¸âƒ£ Entra en la carpeta del proyecto
`cd mi-proyecto`


3ï¸âƒ£ Crea una nueva rama para tus cambios
`git checkout -b nueva-funcionalidad`

âœï¸ QuÃ© hace:

`checkout -b` crea y cambia a una nueva rama llamada nueva-funcionalidad.
AsÃ­ trabajas separado del cÃ³digo principal (main).

ğŸ“˜ Piensa: â€œVoy a trabajar en una copia paralela del proyecto.â€


4ï¸âƒ£ Haz tus cambios

Por ejemplo, editas o agregas un archivo:
index.html, app.js, etc.


5ï¸âƒ£ AÃ±ade tus cambios al Ã¡rea de preparaciÃ³n
`git add .`

âœï¸ QuÃ© hace:
Prepara todos los archivos modificados para ser guardados (commiteados).


6ï¸âƒ£ Guarda los cambios en la rama
`git commit -m "Agrego nueva funcionalidad X"`

 âœï¸ QuÃ© hace:
Crea una versiÃ³n con tus cambios en el historial local de Git.


7ï¸âƒ£ Sube tu rama al repositorio remoto (GitHub)
`git push origin nueva-funcionalidad`

âœï¸ QuÃ© hace:
EnvÃ­a tu rama y tus commits a GitHub.
Ahora GitHub sabe que existe nueva-funcionalidad.


8ï¸âƒ£ Crea el Pull Request en GitHub

Este paso se hace desde la web de GitHub ğŸ§‘â€ğŸ’»:

Ve a tu repositorio (https://github.com/tu-usuario/mi-proyecto).

VerÃ¡s un aviso arriba:
â€œCompare & pull requestâ€ â†’ haz clic.

Escribe: Un tÃ­tulo descriptivo (ej. â€œAgrego nueva funcionalidad Xâ€).

Una descripciÃ³n de lo que hiciste.

Revisa que sea de tu rama â†’ hacia main.

Haz clic en â€œCreate pull requestâ€.


9ï¸âƒ£ Espera revisiÃ³n o aprueba tÃº mismo

ğŸ¥ Si trabajas en equipo: otros revisan el cÃ³digo, pueden dejar comentarios o pedir cambios.

ğŸ¥ Si trabajas solo: puedes aprobarlo tÃº mismo.


ğŸ”Ÿ Fusiona el PR (Merge)

Una vez aprobado:

ğŸ¥ Haz clic en el botÃ³n verde â€œMerge pull requestâ€.

ğŸ¥ Confirma con â€œConfirm mergeâ€.

ğŸ¥ (Opcional) Borra la rama si ya no la necesitas: â€œDelete branchâ€.



âœ… En resumen visual:

ğŸ¥ # 1. Clonar repositorio
git clone URL

ğŸ¥ # 2. Entrar al proyecto
cd mi-proyecto

ğŸ¥ # 3. Crear y moverse a una nueva rama
git checkout -b nueva-funcionalidad

ğŸ¥ # 4. Hacer cambios, luego agregarlos
git add .

ğŸ¥ # 5. Guardarlos localmente
git commit -m "Agrego nueva funcionalidad X"

ğŸ¥ # 6. Subir la nueva rama a GitHub
git push origin nueva-funcionalidad

ğŸ¥ # 7. Crear Pull Request en GitHub (paso manual en la web)


ğŸ’¡ Consejo profesional:
Antes de crear el PR, asegÃºrate de tener tu rama actualizada con la Ãºltima versiÃ³n de main:

`git checkout main`
`git pull origin main`
`git checkout nueva-funcionalidad`
`git merge main`

AsÃ­ evitas conflictos antes de subir tu cÃ³digo.



 ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡

ğŸ˜ Vamos a ver un ejemplo prÃ¡ctico y realista con archivos para entender exactamente quÃ© pasa cuando haces:

`git checkout main
git pull origin main
git checkout nueva-funcionalidad
git merge main`



-------------
ğŸ§© Escenario
-------------

Supongamos que tÃº y tu compaÃ±ero estÃ¡n trabajando en el mismo proyecto de GitHub llamado mi-proyecto.

Tu compaÃ±ero hizo un cambio en main, y tÃº estÃ¡s trabajando en tu propia rama nueva-funcionalidad.
Vamos a ver cÃ³mo se sincroniza todo.



-----------------
ğŸ§± Estado inicial
-----------------
En GitHub (main):

Tu compaÃ±ero ya hizo este cambio y lo subiÃ³:

`index.html
----------------
<h1>Bienvenido al sitio web</h1>
<p>VersiÃ³n 2.0</p>`

En tu computadora, en tu rama nueva-funcionalidad:

TodavÃ­a tienes una versiÃ³n vieja:

`index.html
----------------
<h1>Bienvenido al sitio web</h1>
<p>VersiÃ³n 1.0</p>`

Y ademÃ¡s, tÃº estÃ¡s agregando un nuevo archivo:

`contacto.html
----------------
<h2>PÃ¡gina de contacto</h2>`



ğŸ”§ Paso a paso:

1ï¸âƒ£ Cambias a la rama principal:
`git checkout main`

ğŸ’¬ Ahora estÃ¡s en la rama main local (la copia que tienes en tu PC).


2ï¸âƒ£ Actualizas tu rama principal con GitHub:
`git pull origin main`

ğŸ’¬ Git descarga los Ãºltimos cambios del servidor (los de tu compaÃ±ero).

ğŸ“ Resultado:
Tu rama main local ahora tiene la versiÃ³n actualizada:

`index.html
----------------
<h1>Bienvenido al sitio web</h1>
<p>VersiÃ³n 2.0</p>`


3ï¸âƒ£ Vuelves a tu rama de trabajo:
`git checkout nueva-funcionalidad`

ğŸ’¬ Ahora estÃ¡s de nuevo en tu rama, con tus archivos (todavÃ­a tienes VersiÃ³n 1.0).


4ï¸âƒ£ Fusionas los cambios de main:
`git merge main`


ğŸ’¬ Git compara tu rama con la rama main y actualiza los archivos.

ğŸ“ Resultado final:
Tu rama nueva-funcionalidad ahora tiene:

`index.html
----------------
<h1>Bienvenido al sitio web</h1>
<p>VersiÃ³n 2.0</p>

contacto.html
----------------
<h2>PÃ¡gina de contacto</h2>`

âœ… Ahora tu rama estÃ¡ actualizada con la Ãºltima versiÃ³n del proyecto y mantiene tus cambios.



ğŸ’¡ Si hubiera conflictos...

SupÃ³n que tÃº tambiÃ©n habÃ­as cambiado la misma lÃ­nea en index.html, por ejemplo:

Tu versiÃ³n:

`<p>VersiÃ³n 1.1 (en progreso)</p>`


Y en main estÃ¡:

`<p>VersiÃ³n 2.0</p>`


Cuando hagas el git merge main, Git te avisarÃ¡ de un conflicto:

`CONFLICT (content): Merge conflict in index.html`


Y dentro del archivo verÃ¡s algo asÃ­:

<h1>Bienvenido al sitio web</h1>
<<<<<<< HEAD
<p>VersiÃ³n 1.1 (en progreso)</p>
=======
<p>VersiÃ³n 2.0</p>
>>>>>>> main


ğŸ’¬ Eso significa:

Lo que estÃ¡ entre <<<<<<< HEAD y ======= es tu versiÃ³n.

Lo que estÃ¡ entre ======= y >>>>>>> main es la versiÃ³n del main.

TÃº decides cuÃ¡l conservar (o fusionarlas manualmente), guardas el archivo, y luego haces:

`git add index.html
git commit`

Y Git guardarÃ¡ la versiÃ³n corregida.


------------------
âœ… Resumen visual
------------------

Paso	    Comando	                              QuÃ© pasa	                      Resultado
-------------------------------------------------------------------------------------------------------------
1	        git checkout main	                    Vas a la rama principal	        Preparas para actualizar.

2	        git pull origin main	                Descargas cambios de GitHub	    Tu main estÃ¡ actualizado.

3	        git checkout nueva-funcionalidad	    Regresas a tu rama	            Preparas tu trabajo.

4	        git merge main	                      Fusionas main con tu rama       Tienes lo mÃ¡s nuevo y tus cambios.


ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿

EVITAR TRABAJAR EN LA RAMA PRINCIPAL. LAS RAMAS SON PARA CREAR FUNCIONALIDADES DE UNA APLICACIÃ“N.

ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿


AquÃ­ tienes un diagrama visual tipo lÃ­neas de tiempo y ramas que muestra 
todo el proceso desde que creas una rama, haces cambios, 
y luego creas un Pull Request (PR) hasta hacer el merge en main.


ğŸ§­ Diagrama de flujo del Pull Request (rama â†’ PR â†’ merge):

               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚                Repositorio GitHub             â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Tiempo â†“

main â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
        ^              ^              ^               ^
        â”‚              â”‚              â”‚               â”‚
        â”‚              â”‚              â”‚               â””â”€â”€â”€ Merge del PR (se actualiza main)
        â”‚              â”‚              â”‚
        â”‚              â”‚              â””â”€â”€ Pull Request creado y revisado
        â”‚              â”‚
        â”‚              â””â”€â”€ Cambios subidos a GitHub desde rama
        â”‚
        â””â”€â”€ Rama creada desde main


nueva-funcionalidad
       \
        â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
        â”‚              â”‚              â”‚
        â”‚              â”‚              â””â”€â”€ `git push origin nueva-funcionalidad`
        â”‚              â”‚
        â”‚              â””â”€â”€ `git commit -m "Agrego nueva funcionalidad X"`
        â”‚
        â””â”€â”€ `git checkout -b nueva-funcionalidad`


(DespuÃ©s del merge)
main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
                                                        â–²
                                                        â”‚
                                       Rama fusionada: cÃ³digo de `nueva-funcionalidad`



ğŸ§© ExplicaciÃ³n visual paso a paso

Etapa	      AcciÃ³n	                                    QuÃ© pasa
-----------------------------------------------------------------------------------
ğŸŸ¢ 1	    `git checkout -b nueva-funcionalidad`	          Creas una nueva rama desde main.

ğŸŸ¡ 2	    `git add . + git commit -m "mensaje"`	          Guardas tus cambios locales en esa rama.

ğŸŸ  3	    `git push origin nueva-funcionalidad`	          Subes tu rama a GitHub.

ğŸ”µ 4	    Creas un Pull Request en GitHub	                GitHub compara nueva-funcionalidad con main.

ğŸŸ£ 5	    Revisas y apruebas el PR	                      El equipo (o tÃº) valida los cambios.

ğŸŸ¤ 6	    Merge PR â†’ main	                                Los cambios se fusionan con la rama principal.

âš« 7	    (Opcional) Delete branch	                       Se elimina la rama ya integrada.
-------------------------------------------------------------------------------------


ğŸ§  VisualizaciÃ³n simplificada de ramas:

................................................................................

main:              Aâ”€â”€Bâ”€â”€Câ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
                     \
nueva-funcionalidad:  Dâ”€â”€Eâ”€â”€Fâ”€â”€(PR)â”€â”€â”
                                     â””â”€â”€â”€â†’ Merge â†’ main (Aâ”€â”€Bâ”€â”€Câ”€â”€Dâ”€â”€Eâ”€â”€F)

................................................................................

Aâ€“Bâ€“C â†’ commits originales en main

Dâ€“Eâ€“F â†’ commits nuevos en tu rama

Luego se fusionan (merge) para actualizar main

ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿

El comando git stash es una herramienta muy Ãºtil de Git que te permite 
guardar temporalmente tus cambios sin hacer un commit.

Vamos a verlo paso a paso con ejemplos sencillos ğŸ‘‡

ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©
ğŸ§© Â¿QuÃ© hace git stash?
ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸

ğŸ‘‰ Guarda tus cambios actuales "en un cajÃ³n" temporal
y deja tu carpeta limpia (como si no hubieras modificado nada).

ğŸ’¬ En otras palabras:

â€œGuarda lo que estaba haciendo para retomarlo despuÃ©s.â€


ğŸ§  CuÃ¡ndo se usa:

Imagina esto:

EstÃ¡s trabajando en una nueva funciÃ³n, modificando varios archivos, pero de repente necesitas:

Cambiar de rama (git checkout main)

Hacer un pull o probar algo urgente

â©â© Git no te dejarÃ¡ cambiar de rama si tienes cambios sin guardar.
AhÃ­ entra en juego git stash.


-----------------------
âš™ï¸ Ejemplo paso a paso
-----------------------

ğŸ”¹ 1ï¸âƒ£ EstÃ¡s trabajando y haces algunos cambios:

`# Editas varios archivos
index.html
style.css`



ğŸ”¹ 2ï¸âƒ£ Git ve tus cambios
`git status`


Resultado:

`modified: index.html
modified: style.css`

Pero aÃºn no quieres hacer commit (no has terminado).



ğŸ”¹ 3ï¸âƒ£ Guardas los cambios temporalmente:
`git stash`



ğŸ§âœï¸ğŸ‘‰ QuÃ© pasa:

Git guarda tus modificaciones en una especie de â€œlista de stashesâ€.

Tu carpeta vuelve al estado limpio, como si no hubieras cambiado nada.


ğŸ“˜ Resultado:

`Saved working directory and index state WIP on nueva-funcionalidad: 123abc`



ğŸ”¹ 4ï¸âƒ£ Ahora puedes cambiar de rama o hacer otras cosas
`git checkout main`

âœ… Sin problemas, porque no hay cambios pendientes.



ğŸ”¹ 5ï¸âƒ£ Cuando termines, vuelves a tu rama y recuperas tus cambios
`git checkout nueva-funcionalidad
git stash pop`

  ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡
ğŸ’¬ git stash pop:

ğŸ¥ Recupera los cambios guardados en el Ãºltimo stash.

ğŸ¥ Los aplica de nuevo a tu carpeta.

ğŸ¥ Y los borra de la lista de stashes.

ğŸ‰ Tus archivos vuelven tal como estaban antes de guardarlos.


ğŸ§° Variantes Ãºtiles

Comando	                      QuÃ© hace
--------------------------------------
git stash	                    Guarda tus cambios actuales
git stash save "mensaje"	    Guarda con un nombre o descripciÃ³n
git stash list	              Muestra todos los stashes guardados
git stash pop	                Recupera el Ãºltimo stash y lo elimina
git stash apply	              Recupera el stash pero sin eliminarlo
git stash drop	              Borra un stash especÃ­fico
git stash clear	              Borra todos los stashes guardados.



------------------
ğŸ’¡ Ejemplo visual:
------------------

ğŸ§  Antes del stash:
`trabajo/ (tienes cambios sin guardar)
â”œâ”€â”€ index.html (modificado)
â”œâ”€â”€ style.css (modificado)`


ğŸª£ git stash  â†’ los cambios se guardan temporalmente
trabajo/ (ahora limpio):
`â”œâ”€â”€ index.html (original)
â”œâ”€â”€ style.css (original)`


ğŸ“¦ `git stash list` â†’ muestra los cambios guardados
stash@{0}: WIP on nueva-funcionalidad

ğŸ”™ `git stash pop` â†’ recupera tus cambios
trabajo/ (de nuevo modificado):
`â”œâ”€â”€ index.html (modificado)
â”œâ”€â”€ style.css (modificado)`


--------------
ğŸ§  En resumen

AcciÃ³n	                                      Comando	              QuÃ© hace
-------------------------------------------------------------------------------------------------------------------------------
Guardar tus cambios temporalmente	            git stash	            Limpia tu directorio sin perder el trabajo.

Ver los stashes guardados	                    git stash list	      Muestra tus â€œguardados rÃ¡pidosâ€.

Recuperar el Ãºltimo stash	                    git stash pop	        Aplica y borra el Ãºltimo guardado.

Recuperar sin borrar	                        git stash apply	      Vuelve a aplicar los cambios, pero los mantiene guardados.
-------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------

ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿

  ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ 
ğŸ‘ El comando `git cherry-pick`
------------------------------

Es otro de esos comandos muy poderosos (y a veces un poco mÃ¡gicos ğŸ˜…) en Git.
Te permite tomar un commit especÃ­fico de una rama y aplicarlo en otra, 
sin traer todo el historial de esa rama.


Vamos a verlo de forma clara, visual y con ejemplos reales ğŸ‘‡


ğŸ’ Â¿QuÃ© hace `git cherry-pick?`

`git cherry-pick` copia un commit especÃ­fico de una rama y lo aplica en la rama actual.


ğŸ’¬ En palabras simples:

â€œQuiero traer solo ese cambio, no toda la rama.â€


ğŸ§  CuÃ¡ndo se usa

Algunas situaciones tÃ­picas:

ğŸš‘ Traer una correcciÃ³n urgente desde una rama a otra (por ejemplo, un bugfix de producciÃ³n).

ğŸ” Reutilizar un commit hecho en otra rama sin hacer un merge completo.

ğŸ’¡ Aplicar un cambio puntual que hiciste antes, en un lugar diferente.

----------------------
âš™ï¸ Ejemplo paso a paso
----------------------

ğŸ”¹ Escenario:

.....................
Tienes dos ramas:

main
 â””â”€â”€ Aâ”€â”€Bâ”€â”€C

nueva-funcionalidad
 â””â”€â”€ Dâ”€â”€Eâ”€â”€F
.....................

SupÃ³n que el commit E (de la rama nueva-funcionalidad) corrige un error importante y quieres llevar solo ese commit a main.


ğŸ”¹ 1ï¸âƒ£ Ve a la rama donde quieres aplicar el cambio
`git checkout main`

ğŸ”¹ 2ï¸âƒ£ Usa git cherry-pick con el ID del commit

Primero, obtÃ©n el ID del commit (por ejemplo, con git log):
`git log`


VerÃ¡s algo como:

`commit a1b2c3d4e5f6 (HEAD -> nueva-funcionalidad)
Author: TÃº <tu@email.com>
Message: Corrijo error en validaciÃ³n`


Luego, ejecutas:
`git cherry-pick a1b2c3d4e5f6`



ğŸ”¹ 3ï¸âƒ£ Git aplica ese commit en main

Resultado:

main
 â””â”€â”€ Aâ”€â”€Bâ”€â”€Câ”€â”€E'

ğŸ‘‰ El commit E' es una copia exacta de E (mismo contenido, diferente hash).



ğŸ’¡ Visualmente:

Antes del cherry-pick:
`main:                Aâ”€â”€Bâ”€â”€C
nueva-funcionalidad:      Dâ”€â”€Eâ”€â”€F`


DespuÃ©s del cherry-pick:
`main:                Aâ”€â”€Bâ”€â”€Câ”€â”€E'
nueva-funcionalidad:      Dâ”€â”€Eâ”€â”€F`

âœ… Solo el commit E fue traÃ­do a main â€” sin afectar los demÃ¡s (D, F).



ğŸ§© Si hay conflictosâ€¦

Si el commit que traes modifica lÃ­neas que tambiÃ©n fueron cambiadas en tu rama actual, 
Git te mostrarÃ¡ un mensaje de conflicto:
`error: could not apply a1b2c3d4e5f6... Corrijo error en validaciÃ³n`



Entonces:

ğŸ¥ Editas los archivos para resolver el conflicto.

ğŸ¥ Luego haces:

`git add .
git cherry-pick --continue`


ğŸ¥ Y Git finalizarÃ¡ el proceso.



-------------------
ğŸ§° Variantes Ãºtiles
-------------------

Comando	                              QuÃ© hace
--------------------------------------------------------------------------------------------
`git cherry-pick <hash>`	              Aplica un commit especÃ­fico

`git cherry-pick <hash1> <hash2>`	      Aplica varios commits a la vez

`git cherry-pick <hash1>..<hash2>`      Aplica un rango de commits

`git cherry-pick --abort`	              Cancela el cherry-pick (si hay errores o conflictos)

`git cherry-pick --continue`	          ContinÃºa despuÃ©s de resolver conflictos
--------------------------------------------------------------------------------------------


âš ï¸ CuÃ¡ndo NO usarlo:

ğŸ¥ Evita git cherry-pick cuando:

ğŸ¥ Quieras fusionar ramas completas â†’ usa git merge o git rebase.

ğŸ¥ EstÃ©s trabajando en un flujo con muchos colaboradores (puede duplicar commits).



âœ… En resumen

AcciÃ³n	                              Comando	                        QuÃ© hace
------------------------------------------------------------------------------------------------------------------
Copiar un commit de otra rama	        git cherry-pick <hash>	        Aplica un commit especÃ­fico a tu rama actual
Ver commits disponibles	              git log	                        Muestra el historial y los hashes
Resolver conflictos	                  git cherry-pick --continue	    Finaliza tras resolver conflictos
------------------------------------------------------------------------------------------------------------------


ğŸ’¡ AnalogÃ­a:
Imagina que tienes dos Ã¡rboles de cerezas ğŸŒ³.
Con `git cherry-pick`, eliges una cereza especÃ­fica ğŸ’ (un commit) del otro Ã¡rbol 
y la colocas en el tuyo â€” sin traer todas las ramas.

WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿

