Hola! Este documento recoge informaciÃ³n para que puedas crear un repositorio Local (en tu PC)
y lo subas a GitHub, puedas editarlo tÃº y otros usuarios de GitHub.

Te explico todo paso a paso y con opciones.

Espero que te sea de ayuda. â˜ºï¸

âœï¸ EMPEZAMOS!!

1â©â© Â¿Debo crear una clave SSH? Esto es IMPORTANTE.

RecomendaciÃ³n: sÃ­ si vas a trabajar desde la terminal (Linux / macOS / Git Bash Windows)
o si quieres evitar tener que introducir tokens/contraseÃ±as cada vez.

Ventajas SSH: autentificaciÃ³n sin escribir token cada push, es seguro y ampliamente usado.

Alternativa: HTTPS + Personal Access Token (PAT) o usar GitHub Desktop / GitHub CLI.
Si prefieres PAT, GitHub ahora recomienda los fine-grained tokens cuando sea posible.

2â©â© CÃ³mo crear una clave SSH (opciones y comandos)

Nota: usa ed25519 cuando tu sistema lo soporte (actualmente recomendado).
Si no, rsa -b 4096 es la alternativa.

---

Comprobar si ya tienes una clave:

## `ls -al ~/.ssh`

---

Generar (macOS / Linux / Git Bash):

## `ssh-keygen -t ed25519 -C "tu-email@example.com"`

---

Arrancar el agente SSH y aÃ±adir la clave:

# arrancar ssh-agent:

`eval "$(ssh-agent -s)"`

# aÃ±adir la clave al agente:

## `ssh-add ~/.ssh/id_ed25519`

---

Copiar la clave pÃºblica al portapapeles:

macOS: `pbcopy < ~/.ssh/id_ed25519.pub`

Linux: `xclip -sel clip < ~/.ssh/id_ed25519.pub` (si tienes xclip).
ğŸ‘€ o tambiÃ©n: `cat ~/.ssh/id_ed25519.pub` y copiar a mano

## Windows (Git Bash): `clip < ~/.ssh/id_ed25519.pub`

---

AÃ±adir la clave a GitHub

## En GitHub: esquina superior derecha â†’ Settings â†’ SSH and GPG keys â†’ New SSH key â†’ pega tu clave pÃºblica y guarda.

---

Probar conexiÃ³n

## `ssh -T git@github.com`

## Si todo va bien verÃ¡s un mensaje de bienvenida.

ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿

3â©â© Crear el repositorio (opciones que verÃ¡s en la interfaz web)

Ir a GitHub y pulsar + â†’ New repository (o https://github.com/new).

---

## Pasos / opciones que te aparecerÃ¡n y decisiÃ³n a tomar:

ğŸŒ¿ Owner: eliges tu cuenta personal o una organizaciÃ³n (si perteneces a alguna).

ğŸŒ¿ Repository name: nombre corto y memorable.

ğŸŒ¿ Description (opcional): una lÃ­nea que describa el propÃ³sito.

ğŸŒ¿ Visibility: Public (cualquiera lo puede ver / forkear) o Private
(solo quien tÃº autorices puede ver). Nota: tÃº puedes hacer pÃºblico
y seguir siendo el Ãºnico con control administrativo (no confundir ver vs controlar).

ğŸŒ¿ Initialize this repository with:

ğŸŒ¿ README (crea el primer commit y muestra la pÃ¡gina principal)

ğŸŒ¿ .gitignore (elige plantilla para tu lenguaje)

ğŸŒ¿ LICENSE (elige licencia si quieres permitir usos concretos)
Si ya tienes un repo local con commits, no marques â€œInitialize with READMEâ€
para evitar conflictos: en ese caso crea el repo vacÃ­o y aÃ±ade el remoto desde local (ver abajo).

ğŸŒ¿ Create repository â†’ una vez creado GitHub te mostrarÃ¡ instrucciones (clone URL SSH y HTTPS).

---

ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿

---

## 1ï¸âƒ£ Crear la carpeta y el archivo

ğŸŒ¿ Abre la terminal.

ğŸŒ¿ Crea una carpeta llamada "miPrimerRepositorio" y muÃ©vete dentro de ella:

`mkdir miPrimerRepositorio
cd miPrimerRepositorio`

ğŸŒ¿ Crea un archivo de texto llamado miPrimerGit.txt:

`echo "Â¡Hola, Git!" > miPrimerGit.txt`

âœï¸ Nota: Esto crea el archivo y escribe â€œÂ¡Hola, Git!â€ dentro de Ã©l.

ğŸŒ¿ Abre la carpeta en VS Code para visualizar el archivo:

## code .

---

## 2ï¸âƒ£ Configurar Git

ğŸŒ¿ Si es la primera vez que usas Git en este equipo, configura tu usuario y email:

`git config --global user.name "TuNombre"`
`git config --global user.email "tuemail@ejemplo.com"`

## Esto le dice a Git quiÃ©n hace los cambios.

---

## 3ï¸âƒ£ Inicializar Git

ğŸŒ¿ Inicializa un repositorio Git dentro de la carpeta:

`git init`

ğŸŒ¿ Salida esperada:

`Initialized empty Git repository in /ruta/miPrimerRepositorio/.git/`

## ğŸŒ¿ Ahora tu carpeta estÃ¡ lista para usar Git.

---

## 4ï¸âƒ£ Ver el estado actual de Git

ğŸŒ¿ Usa git status para ver los cambios:

`git status`

ğŸŒ¿ Salida esperada:

`Untracked files:
  (use "git add <file>..." to include in what will be committed)
        miPrimerGit.txt`

## Esto indica que Git ve el archivo pero aÃºn no lo estÃ¡ siguiendo.

---

## 5ï¸âƒ£ Agregar el archivo al Ã¡rea de preparaciÃ³n (staging area):

`git add miPrimerGit.txt`

ğŸŒ¿ Verifica con git status:

`git status`

ğŸŒ¿ Salida esperada:

`Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   miPrimerGit.txt`

## Ahora Git estÃ¡ listo para hacer commit de este archivo.

---

## 6ï¸âƒ£ Hacer el primer commit

```git commit -m "Primer commit: agregamos miPrimerGit.txt"```

ğŸŒ¿ Salida esperada:

```[main (root-commit) 123abcd] Primer commit: agregamos miPrimerGit.txt
 1 file changed, 1 insertion(+)
 create mode 100644 miPrimerGit.txt```

ğŸ‰ Â¡Felicidades! Tu primer commit estÃ¡ hecho.

---

## 7ï¸âƒ£ Ver el historial de commits

ğŸŒ¿ Para ver un historial resumido:

---

| git log --oneline |

---

ğŸŒ¿ Salida esperada:

---

| 123abcd Primer commit: agregamos miPrimerGit.txt |

---

## Esto muestra todos los commits en lÃ­nea.

âœ… Resumen visual en VS Code:

ğŸŒ¿ La carpeta miPrimerRepositorio contiene miPrimerGit.txt.

ğŸŒ¿ git status ğŸŒ¿ muestra si hay cambios pendientes.

ğŸŒ¿ git add ğŸŒ¿ mueve archivos al staging area.

ğŸŒ¿ git commit ğŸŒ¿ guarda los cambios.

ğŸŒ¿ git log --oneline ğŸŒ¿ muestra los commits resumidos.

---

ğŸ›ï¸ Cada rama que creamos tiene que ser creada especÃ­ficamente
para resolver un problema, para crear alguna funcionalidad nueva
o para un objetivo concreto.

---

ğŸ‘ Vamos a ver cÃ³mo subir un archivo a un repositorio de GitHub, paso a paso,
y te explico quÃ© hace cada comando de Git de forma clara y sencilla.

................................
ğŸ§© 1. Inicializar el repositorio
```git init```
................................

QuÃ© hace:
Crea un nuevo repositorio de Git en la carpeta actual.
Git empieza a â€œvigilarâ€ los archivos de esa carpeta para registrar los cambios que hagas.

ğŸ“˜ Ejemplo:
Si estÃ¡s en una carpeta llamada mi-proyecto, este comando crea una subcarpeta oculta .git
que guarda toda la informaciÃ³n de versiones.

..........................................................
ğŸ“„ 2. AÃ±adir los archivos al Ã¡rea de preparaciÃ³n (staging)
`git add nombre_del_archivo`
..........................................................

O para agregar todos los archivos:
`git add .`

QuÃ© hace:
Le dice a Git quÃ© archivos quieres incluir en la prÃ³xima versiÃ³n (commit).
Piensa en esto como â€œmarcarâ€ los archivos que se van a guardar.

ğŸ“˜ Ejemplo:
git add index.html â†’ marca ese archivo.
git add . â†’ marca todos los archivos nuevos o modificados.

.................................................
ğŸ’¾ 3. Guardar los cambios en el repositorio local
`git commit -m "Mensaje descriptivo de los cambios que has realizado en dicho archivo"`
.................................................

QuÃ© hace:
Guarda una â€œfotoâ€ (snapshot) de los archivos aÃ±adidos.
El mensaje entre comillas describe los cambios realizados.

ğŸ“˜ Ejemplo:
`git commit -m "Agrego el archivo index.html con el diseÃ±o inicial"`

ğŸ§ Esto no sube nada a GitHub todavÃ­a, solo guarda el historial en tu computadora.

........................................................................
ğŸŒ 4. Conectar tu repositorio local con el de GitHub:
`git remote add origin https://github.com/usuario/nombre-repositorio.git`
........................................................................

QuÃ© hace:
Le dice a Git dÃ³nde estÃ¡ el repositorio remoto (en GitHub).
â€œoriginâ€ es solo un nombre corto para esa URL.

ğŸ“˜ Ejemplo:
`git remote add origin https://github.com/maria/mi-proyecto.git`

.......................................................
â¬†ï¸ 5. Subir los archivos al repositorio remoto (GitHub)
`git push -u origin main`
.......................................................

QuÃ© hace:
EnvÃ­a (sube) tus commits al repositorio remoto (GitHub).

ğŸ¥ origin â†’ el nombre del remoto que agregaste.

ğŸ¥ main â†’ la rama (branch) principal del proyecto.

ğŸ¥ El -u le dice a Git que recuerde esta conexiÃ³n,
para que la prÃ³xima vez puedas usar solo git push.

ğŸ“˜ Ejemplo:
`git push -u origin main`
Sube todos tus commits guardados a la rama principal en GitHub.

..............................................................
ğŸš€ 6. Actualizar tu repositorio local desde GitHub (opcional)
`git pull origin main`
..............................................................

ğŸ›ï¸ QuÃ© hace:
Descarga los Ãºltimos cambios del repositorio remoto (GitHub) a tu copia local.
Ãštil si trabajas en equipo y alguien mÃ¡s subiÃ³ cambios.

---

## ğŸ” Resumen rÃ¡pido

ğŸ›ï¸AcciÃ³n                            Comando                                     QuÃ© hace

Inicializar repositorio-------> ```git init``` -------------------------------> Empieza a usar Git en una carpeta.
Agregar archivos--------------> ```git add .``` ------------------------------> Marca los archivos a guardar.
Guardar cambios --------------> ```git commit -m "mensaje"``` ----------------> Crea una versiÃ³n local.
Conectar con GitHub ----------> ```git remote add origin URL-de-GitHub``` ----> Vincula tu carpeta local con GitHub.
Subir cambios ----------------> ```git push -u origin main``` ----------------> Sube tus commits a GitHub.
Actualizar desde GitHub ------> ```git pull origin main``` -------------------> Descarga los cambios mÃ¡s recientes.

---

El pull request (a menudo abreviado como PR) es una de las partes mÃ¡s importantes
del flujo de trabajo en GitHub (y otras plataformas como GitLab o Bitbucket).

Vamos a verlo de forma sencilla ğŸ‘‡

...........................
ğŸ§  Â¿QuÃ© es un pull request?
...........................

Un pull request (PR) es una solicitud para fusionar tus cambios (commits) de una rama en otra,
normalmente de tu rama de trabajo hacia la rama principal (main o master) de un repositorio.

ğŸ‘‰ En otras palabras:

â€œOye, he hecho unos cambios en mi rama, Â¿pueden revisarlos y unirlos al proyecto principal?â€

ğŸ§© CuÃ¡ndo se usa:

Se usa principalmente cuando:

ğŸ¥ EstÃ¡s colaborando en equipo.

ğŸ¥ Quieres que otra persona revise tu cÃ³digo antes de integrarlo.

ğŸ¥ Quieres mantener el control y orden del proyecto (no fusionar cambios sin revisar).

.................................
âš™ï¸ Flujo tÃ­pico con pull request
.................................

Creas una rama para tus cambios:

```git checkout -b nueva-funcionalidad```

Esto separa tu trabajo del cÃ³digo principal.

Haces cambios y los subes:

```git add .```
```git commit -m "Agrego nueva funcionalidad X"```
```git push origin nueva-funcionalidad```

Abres un Pull Request en GitHub:

Vas al repositorio en GitHub.

VerÃ¡s un botÃ³n que dice â€œCompare & pull requestâ€.

Escribes una descripciÃ³n de lo que hiciste.

EnvÃ­as el PR.

El equipo revisa el cÃ³digo:
Pueden dejar comentarios, pedir cambios o aprobarlo.

Se hace el merge (fusiÃ³n):
Una vez aprobado, se combinan tus cambios con la rama principal:

```git merge nueva-funcionalidad```

ğŸ’¬ En resumen

AcciÃ³n y QuÃ© hace
Pull Request ----------> Pide que tus cambios se revisen y se unan al cÃ³digo principal

Objetivo Revisar, discutir y aprobar cÃ³digo antes de fusionarlo

DÃ³nde Se hace En GitHub (no en la terminal)

## Beneficio. Mejora la calidad del cÃ³digo, evita errores y fomenta colaboraciÃ³n

ğŸ’¡ AnalogÃ­a sencilla:

Imagina que tÃº escribes un capÃ­tulo nuevo para un libro del equipo.
Antes de que se publique, haces un pull request para que los demÃ¡s autores lo revisen,
lo corrijan si es necesario, y finalmente lo integren al libro oficial ğŸ“–.

Ejemplo completo de flujo de trabajo con ramas y un pull request paso a paso
(como lo harÃ­as tÃº desde la terminal hasta GitHub).

Vamos a hacer un ejemplo completo paso a paso de cÃ³mo trabajar con ramas y crear un Pull Request (PR) en GitHub.

Te voy a guiar como si fueras tÃº escribiendo en la terminal ğŸ–¥ï¸
(Este flujo es el mÃ¡s usado por equipos profesionales).

---

 ğŸš€ Escenario:

Tienes un repositorio en GitHub llamado mi-proyecto.
Quieres agregar una nueva funciÃ³n o cambiar algo, pero sin romper el cÃ³digo principal.

AsÃ­ que trabajas en una rama nueva â†’ haces cambios â†’ los subes â†’ creas un pull request.

ğŸ§© Paso a paso:

1ï¸âƒ£ Clona el repositorio desde GitHub

Si aÃºn no lo tienes en tu computadora:

`git clone https://github.com/tu-usuario/mi-proyecto.git`

âœï¸ QuÃ© hace:
Descarga una copia del repositorio remoto (en GitHub) a tu mÃ¡quina local.

2ï¸âƒ£ Entra en la carpeta del proyecto
`cd mi-proyecto`

3ï¸âƒ£ Crea una nueva rama para tus cambios
`git checkout -b nueva-funcionalidad`

âœï¸ QuÃ© hace:

`checkout -b` crea y cambia a una nueva rama llamada nueva-funcionalidad.
AsÃ­ trabajas separado del cÃ³digo principal (main).

ğŸ“˜ Piensa: â€œVoy a trabajar en una copia paralela del proyecto.â€

4ï¸âƒ£ Haz tus cambios

Por ejemplo, editas o agregas un archivo:
index.html, app.js, etc.

5ï¸âƒ£ AÃ±ade tus cambios al Ã¡rea de preparaciÃ³n
`git add .`

âœï¸ QuÃ© hace:
Prepara todos los archivos modificados para ser guardados (commiteados).

6ï¸âƒ£ Guarda los cambios en la rama
`git commit -m "Agrego nueva funcionalidad X"`

âœï¸ QuÃ© hace:
Crea una versiÃ³n con tus cambios en el historial local de Git.

7ï¸âƒ£ Sube tu rama al repositorio remoto (GitHub)
`git push origin nueva-funcionalidad`

âœï¸ QuÃ© hace:
EnvÃ­a tu rama y tus commits a GitHub.
Ahora GitHub sabe que existe nueva-funcionalidad.

8ï¸âƒ£ Crea el Pull Request en GitHub

Este paso se hace desde la web de GitHub ğŸ§‘â€ğŸ’»:

Ve a tu repositorio (https://github.com/tu-usuario/mi-proyecto).

VerÃ¡s un aviso arriba:
â€œCompare & pull requestâ€ â†’ haz clic.

Escribe: Un tÃ­tulo descriptivo (ej. â€œAgrego nueva funcionalidad Xâ€).

Una descripciÃ³n de lo que hiciste.

Revisa que sea de tu rama â†’ hacia main.

Haz clic en â€œCreate pull requestâ€.

9ï¸âƒ£ Espera revisiÃ³n o aprueba tÃº mismo

ğŸ¥ Si trabajas en equipo: otros revisan el cÃ³digo, pueden dejar comentarios o pedir cambios.

ğŸ¥ Si trabajas solo: puedes aprobarlo tÃº mismo.

ğŸ”Ÿ Fusiona el PR (Merge)

Una vez aprobado:

ğŸ¥ Haz clic en el botÃ³n verde â€œMerge pull requestâ€.

ğŸ¥ Confirma con â€œConfirm mergeâ€.

ğŸ¥ (Opcional) Borra la rama si ya no la necesitas: â€œDelete branchâ€.

âœ… En resumen visual:

ğŸ¥ # 1. Clonar repositorio
git clone URL

ğŸ¥ # 2. Entrar al proyecto
cd mi-proyecto

ğŸ¥ # 3. Crear y moverse a una nueva rama
git checkout -b nueva-funcionalidad

ğŸ¥ # 4. Hacer cambios, luego agregarlos
git add .

ğŸ¥ # 5. Guardarlos localmente
git commit -m "Agrego nueva funcionalidad X"

ğŸ¥ # 6. Subir la nueva rama a GitHub
git push origin nueva-funcionalidad

ğŸ¥ # 7. Crear Pull Request en GitHub (paso manual en la web)

ğŸ’¡ Consejo profesional:
Antes de crear el PR, asegÃºrate de tener tu rama actualizada con la Ãºltima versiÃ³n de main:

```git checkout main```
```git pull origin main```
```git checkout nueva-funcionalidad```
```git merge main```

AsÃ­ evitas conflictos antes de subir tu cÃ³digo.

ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡

ğŸ˜ Vamos a ver un ejemplo prÃ¡ctico y realista con archivos para entender exactamente quÃ© pasa cuando haces:

```git checkout main
git pull origin main
git checkout nueva-funcionalidad
git merge main```

## ğŸ§© Escenario

Supongamos que tÃº y tu compaÃ±ero estÃ¡n trabajando en el mismo proyecto de GitHub llamado mi-proyecto.

Tu compaÃ±ero hizo un cambio en main, y tÃº estÃ¡s trabajando en tu propia rama nueva-funcionalidad.
Vamos a ver cÃ³mo se sincroniza todo.

---

## ğŸ§± Estado inicial

En GitHub (main):

Tu compaÃ±ero ya hizo este cambio y lo subiÃ³:

## `index.html

<h1>Bienvenido al sitio web</h1>
<p>VersiÃ³n 2.0</p>`

En tu computadora, en tu rama nueva-funcionalidad:

TodavÃ­a tienes una versiÃ³n vieja:

## `index.html

<h1>Bienvenido al sitio web</h1>
<p>VersiÃ³n 1.0</p>`

Y ademÃ¡s, tÃº estÃ¡s agregando un nuevo archivo:

## `contacto.html

<h2>PÃ¡gina de contacto</h2>`

---------------
ğŸ”§ Paso a paso:
---------------

1ï¸âƒ£ Cambias a la rama principal:
```git checkout main```

ğŸ’¬ Ahora estÃ¡s en la rama main local (la copia que tienes en tu PC).

2ï¸âƒ£ Actualizas tu rama principal con GitHub:
```git pull origin main```

ğŸ’¬ Git descarga los Ãºltimos cambios del servidor (los de tu compaÃ±ero).

ğŸ“ Resultado:
Tu rama main local ahora tiene la versiÃ³n actualizada:

## ```index.html

<h1>Bienvenido al sitio web</h1>
<p>VersiÃ³n 2.0</p>```

3ï¸âƒ£ Vuelves a tu rama de trabajo:
```git checkout nueva-funcionalidad```

ğŸ’¬ Ahora estÃ¡s de nuevo en tu rama, con tus archivos (todavÃ­a tienes VersiÃ³n 1.0).

4ï¸âƒ£ Fusionas los cambios de main:
```git merge main```

ğŸ’¬ Git compara tu rama con la rama main y actualiza los archivos.

ğŸ“ Resultado final:
Tu rama nueva-funcionalidad ahora tiene:

## ```index.html

<h1>Bienvenido al sitio web</h1>
<p>VersiÃ³n 2.0</p>

## contacto.html

<h2>PÃ¡gina de contacto</h2>```

âœ… Ahora tu rama estÃ¡ actualizada con la Ãºltima versiÃ³n del proyecto y mantiene tus cambios.

ğŸ’¡ Si hubiera conflictos...

SupÃ³n que tÃº tambiÃ©n habÃ­as cambiado la misma lÃ­nea en index.html, por ejemplo:

Tu versiÃ³n:

```<p>VersiÃ³n 1.1 (en progreso)</p>`

Y en main estÃ¡:

`<p>VersiÃ³n 2.0</p>```

Cuando hagas el git merge main, Git te avisarÃ¡ de un conflicto:

```CONFLICT (content): Merge conflict in index.html```

Y dentro del archivo verÃ¡s algo asÃ­:

<h1>Bienvenido al sitio web</h1>
<<<<<<< HEAD
<p>VersiÃ³n 1.1 (en progreso)</p>
=======
<p>VersiÃ³n 2.0</p>
>>>>>>> main

ğŸ’¬ Eso significa:

Lo que estÃ¡ entre <<<<<<< HEAD y ======= es tu versiÃ³n.

Lo que estÃ¡ entre ======= y >>>>>>> main es la versiÃ³n del main.

TÃº decides cuÃ¡l conservar (o fusionarlas manualmente), guardas el archivo, y luego haces:

```git add index.html
git commit```

Y Git guardarÃ¡ la versiÃ³n corregida.

---

## âœ… Resumen visual

## Pasos:

Comando                                 QuÃ© pasa                         Resultado

1 git checkout main ....................Vas a la rama principal .........Preparas para actualizar.

2 git pull origin main .................Descargas cambios de GitHub .....Tu main estÃ¡ actualizado.

3 git checkout nueva-funcionalidad .....Regresas a tu rama ..............Preparas tu trabajo.

4 git merge main .......................Fusionas main con tu rama .......Tienes lo mÃ¡s nuevo y tus cambios.

ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿

EVITAR TRABAJAR EN LA RAMA PRINCIPAL. LAS RAMAS SON PARA CREAR FUNCIONALIDADES DE UNA APLICACIÃ“N.

ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿

AquÃ­ tienes un diagrama visual tipo lÃ­neas de tiempo y ramas que muestra
todo el proceso desde que creas una rama, haces cambios,
y luego creas un Pull Request (PR) hasta hacer el merge en main.

ğŸ§­ Diagrama de flujo del Pull Request (rama â†’ PR â†’ merge):

               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚                Repositorio GitHub             â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Tiempo â†“

main â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
^ ^ ^ ^
â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ â””â”€â”€â”€ Merge del PR (se actualiza main)
â”‚ â”‚ â”‚
â”‚ â”‚ â””â”€â”€ Pull Request creado y revisado
â”‚ â”‚
â”‚ â””â”€â”€ Cambios subidos a GitHub desde rama
â”‚
â””â”€â”€ Rama creada desde main

nueva-funcionalidad
\
 â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
â”‚ â”‚ â”‚
â”‚ â”‚ â””â”€â”€ `git push origin nueva-funcionalidad`
â”‚ â”‚
â”‚ â””â”€â”€ `git commit -m "Agrego nueva funcionalidad X"`
â”‚
â””â”€â”€ `git checkout -b nueva-funcionalidad`

(DespuÃ©s del merge)
main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
â–²
â”‚
Rama fusionada: cÃ³digo de `nueva-funcionalidad`

ğŸ§© ExplicaciÃ³n visual paso a paso

## Etapa AcciÃ³n QuÃ© pasa

ğŸŸ¢ 1 `git checkout -b nueva-funcionalidad` Creas una nueva rama desde main.

ğŸŸ¡ 2 `git add . + git commit -m "mensaje"` Guardas tus cambios locales en esa rama.

ğŸŸ  3 `git push origin nueva-funcionalidad` Subes tu rama a GitHub.

ğŸ”µ 4 Creas un Pull Request en GitHub GitHub compara nueva-funcionalidad con main.

ğŸŸ£ 5 Revisas y apruebas el PR El equipo (o tÃº) valida los cambios.

ğŸŸ¤ 6 Merge PR â†’ main Los cambios se fusionan con la rama principal.

## âš« 7 (Opcional) Delete branch Se elimina la rama ya integrada.

ğŸ§  VisualizaciÃ³n simplificada de ramas:

................................................................................

main: Aâ”€â”€Bâ”€â”€Câ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
\
nueva-funcionalidad: Dâ”€â”€Eâ”€â”€Fâ”€â”€(PR)â”€â”€â”
â””â”€â”€â”€â†’ Merge â†’ main (Aâ”€â”€Bâ”€â”€Câ”€â”€Dâ”€â”€Eâ”€â”€F)

................................................................................

Aâ€“Bâ€“C â†’ commits originales en main

Dâ€“Eâ€“F â†’ commits nuevos en tu rama

Luego se fusionan (merge) para actualizar main

ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿

El comando git stash es una herramienta muy Ãºtil de Git que te permite
guardar temporalmente tus cambios sin hacer un commit.

Vamos a verlo paso a paso con ejemplos sencillos ğŸ‘‡

ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©
ğŸ§© Â¿QuÃ© hace git stash?
ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸ğŸ›ï¸

ğŸ‘‰ Guarda tus cambios actuales "en un cajÃ³n" temporal
y deja tu carpeta limpia (como si no hubieras modificado nada).

ğŸ’¬ En otras palabras:

â€œGuarda lo que estaba haciendo para retomarlo despuÃ©s.â€

ğŸ§  CuÃ¡ndo se usa:

Imagina esto:

EstÃ¡s trabajando en una nueva funciÃ³n, modificando varios archivos, pero de repente necesitas:

Cambiar de rama (git checkout main)

Hacer un pull o probar algo urgente

â©â© Git no te dejarÃ¡ cambiar de rama si tienes cambios sin guardar.
AhÃ­ entra en juego git stash.

---

## âš™ï¸ Ejemplo paso a paso

ğŸ”¹ 1ï¸âƒ£ EstÃ¡s trabajando y haces algunos cambios:

`# Editas varios archivos
index.html
style.css`

ğŸ”¹ 2ï¸âƒ£ Git ve tus cambios
`git status`

Resultado:

`modified: index.html
modified: style.css`

Pero aÃºn no quieres hacer commit (no has terminado).

ğŸ”¹ 3ï¸âƒ£ Guardas los cambios temporalmente:
`git stash`

ğŸ§âœï¸ğŸ‘‰ QuÃ© pasa:

Git guarda tus modificaciones en una especie de â€œlista de stashesâ€.

Tu carpeta vuelve al estado limpio, como si no hubieras cambiado nada.

ğŸ“˜ Resultado:

`Saved working directory and index state WIP on nueva-funcionalidad: 123abc`

ğŸ”¹ 4ï¸âƒ£ Ahora puedes cambiar de rama o hacer otras cosas
`git checkout main`

âœ… Sin problemas, porque no hay cambios pendientes.

ğŸ”¹ 5ï¸âƒ£ Cuando termines, vuelves a tu rama y recuperas tus cambios
`git checkout nueva-funcionalidad
git stash pop`

ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡
ğŸ’¬ git stash pop:

ğŸ¥ Recupera los cambios guardados en el Ãºltimo stash.

ğŸ¥ Los aplica de nuevo a tu carpeta.

ğŸ¥ Y los borra de la lista de stashes.

ğŸ‰ Tus archivos vuelven tal como estaban antes de guardarlos.

ğŸ§° Variantes Ãºtiles

## Comando                       QuÃ© hace

git stash                         Guarda tus cambios actuales
git stash save "mensaje"          Guarda con un nombre o descripciÃ³n
git stash list                    Muestra todos los stashes guardados
git stash pop                     Recupera el Ãºltimo stash y lo elimina
git stash apply                   Recupera el stash pero sin eliminarlo
git stash drop                    Borra un stash especÃ­fico
git stash clear                   Borra todos los stashes guardados.

------------------------------------------------------------------------

## ğŸ’¡ Ejemplo visual:

ğŸ§  Antes del stash:
`trabajo/ (tienes cambios sin guardar)
â”œâ”€â”€ index.html (modificado)
â”œâ”€â”€ style.css (modificado)`

ğŸª£ git stash â†’ los cambios se guardan temporalmente
trabajo/ (ahora limpio):
`â”œâ”€â”€ index.html (original)
â”œâ”€â”€ style.css (original)`

ğŸ“¦ `git stash list` â†’ muestra los cambios guardados
stash@{0}: WIP on nueva-funcionalidad

ğŸ”™ `git stash pop` â†’ recupera tus cambios
trabajo/ (de nuevo modificado):
`â”œâ”€â”€ index.html (modificado)
â”œâ”€â”€ style.css (modificado)`

---

ğŸ§  En resumen

AcciÃ³n                                      Comando                           QuÃ© hace
.......................................................................................................................................

Guardar tus cambios temporalmente           git stash                       Limpia tu directorio sin perder el trabajo.

Ver los stashes guardados                   git stash list                  Muestra tus â€œguardados rÃ¡pidosâ€.

Recuperar el Ãºltimo stash                   git stash pop                   Aplica y borra el Ãºltimo guardado.

## Recuperar sin borrar                     git stash apply                 Vuelve a aplicar los cambios, pero los mantiene guardados.

----------------------------------------------------------------------------------------------------------------------------------------

ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿

ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡ ğŸ‘‡
ğŸ‘ El comando `git cherry-pick`

---

Es otro de esos comandos muy poderosos (y a veces un poco mÃ¡gicos ğŸ˜…) en Git.
Te permite tomar un commit especÃ­fico de una rama y aplicarlo en otra,
sin traer todo el historial de esa rama.

Vamos a verlo de forma clara, visual y con ejemplos reales ğŸ‘‡

ğŸ’ Â¿QuÃ© hace `git cherry-pick?`

`git cherry-pick` copia un commit especÃ­fico de una rama y lo aplica en la rama actual.

ğŸ’¬ En palabras simples:

â€œQuiero traer solo ese cambio, no toda la rama.â€

ğŸ§  CuÃ¡ndo se usa

Algunas situaciones tÃ­picas:

ğŸš‘ Traer una correcciÃ³n urgente desde una rama a otra (por ejemplo, un bugfix de producciÃ³n).

ğŸ” Reutilizar un commit hecho en otra rama sin hacer un merge completo.

ğŸ’¡ Aplicar un cambio puntual que hiciste antes, en un lugar diferente.

---

## âš™ï¸ Ejemplo paso a paso

ğŸ”¹ Escenario:

.....................
Tienes dos ramas:

main
â””â”€â”€ Aâ”€â”€Bâ”€â”€C

nueva-funcionalidad
â””â”€â”€ Dâ”€â”€Eâ”€â”€F
.....................

SupÃ³n que el commit E (de la rama nueva-funcionalidad) corrige un error importante y quieres llevar solo ese commit a main.

ğŸ”¹ 1ï¸âƒ£ Ve a la rama donde quieres aplicar el cambio
`git checkout main`

ğŸ”¹ 2ï¸âƒ£ Usa git cherry-pick con el ID del commit

Primero, obtÃ©n el ID del commit (por ejemplo, con git log):
`git log`

VerÃ¡s algo como:

`commit a1b2c3d4e5f6 (HEAD -> nueva-funcionalidad)
Author: TÃº <tu@email.com>
Message: Corrijo error en validaciÃ³n`

Luego, ejecutas:
`git cherry-pick a1b2c3d4e5f6`

ğŸ”¹ 3ï¸âƒ£ Git aplica ese commit en main

Resultado:

main
â””â”€â”€ Aâ”€â”€Bâ”€â”€Câ”€â”€E'

ğŸ‘‰ El commit E' es una copia exacta de E (mismo contenido, diferente hash).

ğŸ’¡ Visualmente:

Antes del cherry-pick:
`main:                Aâ”€â”€Bâ”€â”€C
nueva-funcionalidad:      Dâ”€â”€Eâ”€â”€F`

DespuÃ©s del cherry-pick:
`main:                Aâ”€â”€Bâ”€â”€Câ”€â”€E'
nueva-funcionalidad:      Dâ”€â”€Eâ”€â”€F`

âœ… Solo el commit E fue traÃ­do a main â€” sin afectar los demÃ¡s (D, F).

ğŸ§© Si hay conflictosâ€¦

Si el commit que traes modifica lÃ­neas que tambiÃ©n fueron cambiadas en tu rama actual,
Git te mostrarÃ¡ un mensaje de conflicto:
`error: could not apply a1b2c3d4e5f6... Corrijo error en validaciÃ³n`

Entonces:

ğŸ¥ Editas los archivos para resolver el conflicto.

ğŸ¥ Luego haces:

`git add .
git cherry-pick --continue`

ğŸ¥ Y Git finalizarÃ¡ el proceso.

---

## ğŸ§° Variantes Ãºtiles

## Comando QuÃ© hace

`git cherry-pick <hash>` Aplica un commit especÃ­fico

`git cherry-pick <hash1> <hash2>` Aplica varios commits a la vez

`git cherry-pick <hash1>..<hash2>` Aplica un rango de commits

`git cherry-pick --abort` Cancela el cherry-pick (si hay errores o conflictos)

## `git cherry-pick --continue` ContinÃºa despuÃ©s de resolver conflictos

âš ï¸ CuÃ¡ndo NO usarlo:

ğŸ¥ Evita git cherry-pick cuando:

ğŸ¥ Quieras fusionar ramas completas â†’ usa git merge o git rebase.

ğŸ¥ EstÃ©s trabajando en un flujo con muchos colaboradores (puede duplicar commits).

âœ… En resumen

## AcciÃ³n Comando QuÃ© hace

Copiar un commit de otra rama git cherry-pick <hash> Aplica un commit especÃ­fico a tu rama actual
Ver commits disponibles git log Muestra el historial y los hashes
Resolver conflictos git cherry-pick --continue Finaliza tras resolver conflictos

---

ğŸ’¡ AnalogÃ­a:
Imagina que tienes dos Ã¡rboles de cerezas ğŸŒ³.
Con `git cherry-pick`, eliges una cereza especÃ­fica ğŸ’ (un commit) del otro Ã¡rbol
y la colocas en el tuyo â€” sin traer todas las ramas.

ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿

git bisect es un comando muy Ãºtil y potente que sirve para encontrar
en quÃ© commit apareciÃ³ un error o bug dentro de un proyecto.

Vamos a explicarlo de forma sencilla y con un ejemplo realista ğŸ‘‡

---

## ğŸ§  Â¿QuÃ© hace git bisect?

git bisect busca el commit que introdujo un error, usando bÃºsqueda binaria (mitad y mitad).

ğŸ’¬ En palabras simples:

â€œGit prueba versiones anteriores de tu cÃ³digo una por una, hasta encontrar el commit exacto donde empezÃ³ a fallar.â€

ğŸ§© CuÃ¡ndo se usa:

Imagina esto:

Tu proyecto funcionaba bien ayer, pero hoy algo se rompiÃ³ ğŸ˜©
Sabes que el error apareciÃ³ en algÃºn commit reciente, pero no sabes cuÃ¡l.

ğŸ‘‰ En lugar de revisar manualmente 100 commits,
git bisect te ayuda a encontrar exactamente cuÃ¡l commit introdujo el fallo.

---

## âš™ï¸ Ejemplo paso a paso

Supongamos que tienes un historial asÃ­:

A â€” B â€” C â€” D â€” E â€” F â€” G

Y sabes:

ğŸ¥ En el commit B â†’ todo funcionaba bien. âœ…

ğŸ¥ En el commit G â†’ el programa falla. âŒ

ğŸ¥ TÃº quieres saber en quÃ© commit exacto entre B y G apareciÃ³ el error.

ğŸ”¹ 1ï¸âƒ£ Inicia el modo bisect
`git bisect start`

ğŸ‘‰ Esto le dice a Git:
â€œVoy a empezar una bÃºsqueda para encontrar el commit malo.â€

ğŸ”¹ 2ï¸âƒ£ Indica el commit malo
`git bisect bad`

ğŸ‘‰ Esto marca el commit actual (por ejemplo, G) como "malo" â€” el que contiene el error.

ğŸ”¹ 3ï¸âƒ£ Indica un commit bueno
`git bisect good B`

ğŸ‘‰ AquÃ­ le dices a Git quÃ© commit sabÃ­as que funcionaba bien.

ğŸ”¹ 4ï¸âƒ£ Git empieza la bÃºsqueda automÃ¡tica:

Git ahora saltarÃ¡ al punto medio entre los dos commits (por ejemplo, el commit D) y te dirÃ¡:

`Bisecting: 3 revisions left to test after this (roughly 2 steps)`

ğŸ”¹ 5ï¸âƒ£ Pruebas tu programa

ğŸ‘‰ Si el error estÃ¡ presente â†’ ejecutas:

`git bisect bad`

ğŸ‘‰ Si todo funciona bien â†’ ejecutas:

`git bisect good`

ğŸ‘‰ Git volverÃ¡ a saltar al siguiente punto medio automÃ¡ticamente.

ğŸ”¹ 6ï¸âƒ£ Git repite el proceso

Cada vez que le dices â€œbuenoâ€ o â€œmaloâ€, Git descarta la mitad de los commits.
AsÃ­, en muy pocos pasos (logarÃ­tmicamente), encuentra el commit exacto que introdujo el bug.

ğŸ”¹ 7ï¸âƒ£ Cuando Git encuentra el culpable ğŸ˜ˆ

Git te mostrarÃ¡ algo como:

`a1b2c3d4e5f6 is the first bad commit
Author: Juan PÃ©rez
Message: "Cambio el cÃ¡lculo de precios"`

ğŸ‘‰ Â¡Listo!
Ese commit es el que introdujo el error.

ğŸ”¹ 8ï¸âƒ£ Salir del modo bisect
`git bisect reset`

ğŸ‘‰ Esto te devuelve a la rama y estado original.

ğŸ’¡ Visualmente
A â€” B â€” C â€” D â€” E â€” F â€” G
â†‘ â†‘ â†‘
good âœ… test ğŸ” bad âŒ

ğŸ‘‰ Git prueba mitad por mitad hasta encontrar el commit exacto que rompe algo.

ğŸ‘‰ ğŸ‘‰ ğŸ§° Resumen rÃ¡pido

## Comando                      QuÃ© hace

`git bisect start` .............Inicia la bÃºsqueda.

`git bisect bad` ...............Marca el commit actual como malo.

`git bisect good <hash>` .......Marca un commit como bueno.

`git bisect reset` .............Sale del modo bisect.

(entre medio) Git prueba commits hasta encontrar el culpable


......................
âš¡ En resumen sencillo:
......................

ğŸ” git bisect es como un detective automÃ¡tico:
te ayuda a encontrar cuÃ¡l commit introdujo un error,
probando versiones anteriores del proyecto mitad por mitad hasta dar con el culpable.

WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿

Cuando ejecutas:

## `$ git checkout`

No especificaste una rama ni un commit,
asÃ­ que Git no cambiÃ³ de rama.

Lo que hizo fue mostrarte el estado actual de tu rama.

El mensaje que te devolviÃ³ significa lo siguiente:

`Your branch is ahead of 'origin/master' by 9 commits.
(use "git push" to publish your local commits)`

ğŸ” InterpretaciÃ³n

ğŸ¥ "Your branch" â†’ EstÃ¡s actualmente en una rama local (probablemente master o main).

ğŸ¥ "is ahead of 'origin/master' by 9 commits" â†’ Tu rama local tiene 9 commits mÃ¡s que la versiÃ³n remota (origin/master).

ğŸ¥ "use 'git push' to publish your local commits" â†’ Es una sugerencia: puedes ejecutar:

`git push`

Para subir esos 9 commits al repositorio remoto (GitHub, GitLab, etc.).



ğŸ’¡ En resumen

No hiciste ningÃºn cambio con git checkout en este caso
solo ejecutaste el comando sin argumentos, y Git te recordÃ³ el estado de sincronizaciÃ³n con el remoto.

Si quieres ver en quÃ© rama estÃ¡s y quÃ© commits te faltan o sobran, puedes usar:

`git status`

o

`git log origin/master..HEAD --onelineÂ´

para listar los 9 commits que aÃºn no subiste.

.....................................................................................................
.....................................................................................................
.....................................................................................................
.....................................................................................................

---

ğŸ‘ Vamos paso a paso para que sincronices tus cambios de forma segura con GitHub (sin perder trabajo).

ğŸ§­ SituaciÃ³n actual

Tu mensaje indica:

`Your branch is ahead of 'origin/master' by 9 commits.`

Eso significa:

Has hecho 9 commits localmente.

Esos commits aÃºn no estÃ¡n en el remoto (origin/master).

No hay conflictos por ahora.



âœ… OPCIÃ“N 1: Subir tus cambios al remoto (lo mÃ¡s comÃºn)

Si estÃ¡s seguro de que nadie mÃ¡s estÃ¡ modificando master en el remoto, simplemente ejecuta:

`git push`

Esto enviarÃ¡ tus 9 commits al repositorio remoto (origin/master).

DespuÃ©s, Git mostrarÃ¡ algo como:

`To github.com:usuario/repositorio.git
   a1b2c3d..d4e5f6g  master -> master`

Y todo quedarÃ¡ sincronizado.



âš ï¸ OPCIÃ“N 2: Actualizar antes de subir (si otros tambiÃ©n trabajan en master)

Si no estÃ¡s seguro de si alguien mÃ¡s ha hecho cambios, primero sincroniza para evitar sobrescribir nada:

`git fetch origin
git merge origin/master`

o, si prefieres una historia mÃ¡s limpia (sin commits de merge):

`git pull --rebase`

Esto traerÃ¡ los cambios remotos y colocarÃ¡ tus 9 commits encima de ellos.

Luego, ya puedes subirlos:

`git push`



ğŸ§° Consejo prÃ¡ctico

Para revisar quÃ© commits tienes de mÃ¡s antes de subir:

`git log origin/master..HEAD --oneline`

Eso te mostrarÃ¡ tus 9 commits pendientes.
Ejemplo de salida:

`abc1234  Fix: corregido bug en login
def5678  Add: validaciÃ³n de usuario`
...



ğŸš€ Resumen rÃ¡pido

AcciÃ³n                                Comando                                       CuÃ¡ndo usar
....................................................................................................................

Subir tus commits al remoto ......... `git push` ....................................Si solo tÃº trabajas en la rama
Traer cambios antes de subir ........ `git pull --rebase` ...........................Si hay otros colaboradores
Ver quÃ© falta por subir ............. `git log origin/master..HEAD --oneline` .......Antes de empujar cambios


ğŸ‘Œ te lo explico breve y claro:

Si ejecutas ahora:

`git push`

ğŸ‘‰ Git subirÃ­a tus 9 commits locales a la rama remota (origin/master).
El resultado serÃ­a que el remoto quedarÃ­a actualizado con todos tus cambios.

En concreto:

Tu historial local y el remoto quedarÃ­an idÃ©nticos.

Nadie perderÃ­a nada si nadie mÃ¡s ha modificado master en el remoto.

Git te mostrarÃ­a una salida similar a:

`To github.com:usuario/repositorio.git
   123abcd..456efgh  master -> master`

âš ï¸ Riesgo:
Si alguien mÃ¡s ya hizo commits en el remoto (despuÃ©s de tu Ãºltima actualizaciÃ³n), tu push podrÃ­a ser rechazado con un mensaje tipo:

`! [rejected] master -> master (fetch first)`

## En ese caso tendrÃ­as que hacer un git pull --rebase antes de poder subir.

---

Te voy a mostrar lo que Git harÃ­a internamente y cÃ³mo se verÃ­an los pasos,
como si estuvieras en tu terminal.

ğŸ§ª Escenario simulado

Supongamos que:

EstÃ¡s en la rama master.

Has hecho 9 commits locales nuevos.

El remoto (origin/master) estÃ¡ sin esos commits.


1ï¸âƒ£ Estado actual
`$ git status
On branch master
Your branch is ahead of 'origin/master' by 9 commits.
  (use "git push" to publish your local commits)
nothing to commit, working tree clean`

Esto te dice: â€œtienes 9 commits pendientes por subirâ€.


2ï¸âƒ£ Ver quÃ© commits subirÃ­as
`$ git log origin/master..HEAD --oneline
8a7f1d3  Fix: error en login
a3e9b21  Add: validaciÃ³n de email
6f4a8de  Refactor: funciÃ³n de autenticaciÃ³n`
...

Estos son los commits que no existen aÃºn en el remoto.


3ï¸âƒ£ Hacer el push
`$ git push
Enumerating objects: 25, done.
Counting objects: 100% (25/25), done.
Delta compression using up to 8 threads
Compressing objects: 100% (12/12), done.
Writing objects: 100% (25/25), 3.2 KiB | 3.2 MiB/s, done.
Total 25 (delta 10), reused 0 (delta 0), pack-reused 0
To github.com:usuario/repositorio.git
   3f4b2a1..8a7f1d3  master -> master`


âœ… QuÃ© acaba de pasar:

Git subiÃ³ los 9 commits al remoto.

origin/master ahora apunta al mismo commit que tu master local.

Ya no verÃ¡s el mensaje â€œahead by 9 commitsâ€.

4ï¸âƒ£ VerificaciÃ³n despuÃ©s del push
`$ git status
On branch master
Your branch is up to date with 'origin/master'.
nothing to commit, working tree clean`

ğŸ’¡ Todo sincronizado. Tu rama local = tu rama remota.

âš ï¸ Si el remoto tenÃ­a cambios nuevos

Si alguien mÃ¡s subiÃ³ algo mientras tÃº trabajabas, Git te avisarÃ­a asÃ­:

`! [rejected] master -> master (fetch first)
error: failed to push some refs to 'github.com:usuario/repositorio.git'
hint: Updates were rejected because the remote contains work that you do
not have locally. Integrate the remote changes before pushing again.`

Y tÃº lo resolverÃ­as con:

`git pull --rebase
git push`

........................
........................

........................
........................

ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©ğŸ§©
Perfecto, vamos a otra cosa. ğŸ‘
â€” hay dos formas de cambiar la extensiÃ³n de un archivo en Git y GitHub,
(segÃºn prefieras hacerlo desde la web de GitHub o desde tu ordenador con Git).

---

## Te explico ambas ğŸ‘‡

ğŸ–¥ï¸ OPCIÃ“N 1 â€” Cambiarlo directamente en GitHub (mÃ¡s fÃ¡cil)

1- Entra a tu repositorio en GitHub.

2- Abre el archivo .txt que quieres cambiar.

3- Arriba a la derecha, haz clic en el Ã­cono de lÃ¡piz âœï¸ (editar archivo).

4- En la parte superior, donde aparece el nombre del archivo (por ejemplo, archivo.txt), cambia la extensiÃ³n a .md, por ejemplo:

archivo.md

Baja hasta el final y aÃ±ade un mensaje de commit, como:

`rename file to markdown format`

Pulsa â€œCommit changesâ€.

âœ… GitHub automÃ¡ticamente renombrarÃ¡ el archivo, y ahora se mostrarÃ¡ con formato Markdown, renderizando los backticks (` `) correctamente.





ğŸ’» OPCIÃ“N 2 â€” Cambiarlo desde tu PC (usando Git)

Si trabajas con el repositorio clonado en tu ordenador:

1- Abre la terminal o VS Code.

2- Cambia el nombre del archivo:

`git mv archivo.txt archivo.md`

3- Confirma el cambio:

`git commit -m "Rename archivo.txt to archivo.md"`

4- Sube los cambios a GitHub:

`git pushÂ´

Cuando actualices la pÃ¡gina del repositorio, verÃ¡s el archivo con su nuevo nombre y formato renderizado correctamente.


ğŸ¥ğŸ¥ Ahora tenemos que actualizar nuestro repositorio local de git con los archivos actualizados de github, cÃ³mo lo hago?

ğŸ‘ â€” Si has cambiado el archivo directamente en GitHub (en la web), tu repositorio local todavÃ­a no sabe que hay un cambio.
AsÃ­ que ahora debes sincronizarlo con GitHub para traer los cambios mÃ¡s recientes.



## AquÃ­ te explico paso a paso cÃ³mo hacerlo ğŸ‘‡

ğŸ”„ ACTUALIZAR TU REPOSITORIO LOCAL CON LOS CAMBIOS DE GITHUB:


ğŸ§­ Paso 1 â€” Abre tu repositorio local

Abre la terminal o el panel de Git en VS Code, y asegÃºrate de estar dentro de la carpeta del repositorio:

`cd nombre-de-tu-repositorio`



ğŸ§­ Paso 2 â€” Comprueba en quÃ© rama estÃ¡s

Normalmente es la rama principal (main o master):

`git branch`

Si no estÃ¡s en la rama principal, cambia con:

`git checkout main`



ğŸ” Paso 3 â€” Descarga los cambios desde GitHub
`git pull origin main`

Esto le dice a Git:

â€œTrae los cambios mÃ¡s recientes desde el repositorio remoto (GitHub) en la rama main y actualiza mi copia localâ€.


âš ï¸ Si has hecho cambios locales sin subirlos:

Si Git te muestra un mensaje de conflicto o error como:

`error: Your local changes to the following files would be overwritten...`

Entonces primero guarda o descarta tus cambios antes de hacer el pull.
Por ejemplo:

Para guardar (commit) antes de sincronizar:

`git add .
git commit -m "guardar cambios locales"
git pull origin main`

O para descartar tus cambios locales:

`git reset --hard origin/main`

âœ… Paso 4 â€” Verifica que el cambio se descargÃ³

Comprueba que ahora en tu carpeta local aparece el archivo con extensiÃ³n .md.

HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH

Perfecto, acabamos de editar el archivo en VS Code, y lo queremos
actualizar en GitHub ğŸ”¥

â€” Si ya tienes hecho el commit localmente:

`git add nombre-del-archivo
git commit -m "comentario de lo que hemos actualizado"`

lo Ãºnico que falta es subir (push) tus cambios a GitHub
para que el archivo del repositorio remoto se actualice.

AquÃ­ van los pasos exactos ğŸ‘‡

ğŸš€ SUBIR TU CAMBIO DE VS CODE / GIT LOCAL A GITHUB.



ğŸ§­ 1ï¸âƒ£ Verifica en quÃ© rama estÃ¡s

Abre la terminal en VS Code o en Git y ejecuta:

`git branch`

Normalmente serÃ¡ la rama principal (main o master).

Si no estÃ¡s en ella:

`git checkout main`



â¬†ï¸ 2ï¸âƒ£ Sube los cambios al repositorio remoto

Usa:

`git push origin main`

ğŸ“Œ Esto significa:

ğŸ¥ git push â†’ sube tus commits locales

ğŸ¥ origin â†’ nombre del repositorio remoto (GitHub)

ğŸ¥ main â†’ la rama donde subirÃ¡s los cambios



ğŸ”„ 3ï¸âƒ£ Comprueba que se actualizÃ³

Ve a tu repositorio en GitHub y refresca la pÃ¡gina:
âœ… VerÃ¡s tu archivo archivoGit.md actualizado con el Ãºltimo contenido que comiteaste.

ğŸ§© (Opcional) Si es la primera vez que haces push en este repo

Git puede pedirte establecer la rama de seguimiento. En ese caso usa:

`git push -u origin main`

El -u (â€œupstreamâ€) le dice a Git que recuerde la conexiÃ³n con GitHub para que en el futuro solo necesites escribir:

`git push`

ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿

â©ğŸ›ï¸âœï¸ğŸ‘‰ Para no perder el control entre lo que tienes localmente (en tu PC)
y lo que estÃ¡ subido a GitHub (remoto).

AquÃ­ te explico varias formas â€”tanto con comandos como desde VS Codeâ€” para ver quÃ© cambios locales no estÃ¡n aÃºn en GitHub ğŸ‘‡


## ğŸ§  OPCIÃ“N 1 â€” Desde la terminal (lÃ­nea de comandos)

ğŸ”¹ 1ï¸âƒ£ Ver quÃ© archivos has modificado localmente (sin subir ni hacer commit)
`git status`
ğŸ‘‡
Esto te muestra:

ğŸ¥ Archivos modificados pero no aÃ±adidos (modified:)

ğŸ¥ Archivos nuevos (untracked:)

ğŸ¥ Archivos ya comiteados pero aÃºn no subidos
(te lo dice en un mensaje tipo â€œYour branch is ahead of 'origin/main' by 1 commitâ€).

    Si ves ese mensaje, significa que tienes commits locales pendientes de subir a GitHub.


ğŸ”¹ 2ï¸âƒ£ Ver exactamente quÃ© commits tienes localmente y que no estÃ¡n en GitHub:
`git log origin/main..HEAD`

Esto muestra los commits que existen en tu copia local pero no en GitHub.
ğŸ‰ Si no aparece nada, estÃ¡s sincronizado.


ğŸ”¹ 3ï¸âƒ£ Ver quÃ© cambios de cÃ³digo hay entre tu repositorio local y GitHub:
`git diff origin/main`

Esto te muestra las diferencias lÃ­nea por lÃ­nea entre tu versiÃ³n local y la remota.





## ğŸ’» OPCIÃ“N 2 â€” Desde VS Code (interfaz visual)

Abre el panel de control de Source Control (icono de ramas o Ctrl+Shift+G / âŒ˜+Shift+G).

AhÃ­ verÃ¡s:

ğŸ¥ Archivos modificados en tu mÃ¡quina.

ğŸ¥ Si ya hiciste commit, pero no hiciste push, VS Code mostrarÃ¡ un contador como â†‘1 al lado de la rama (arriba de todo).

ğŸ¥ â†‘1 = 1 commit local pendiente de subir.

ğŸ¥ â†“1 = 1 commit en GitHub pendiente de bajar (pull).

ğŸ¥ Puedes hacer clic en un archivo para ver las diferencias (diff) visualmente.

ğŸ§© OPCIONAL â€” Ver estado general de sincronizaciÃ³n

TambiÃ©n puedes usar:

`git fetch
git status`

Esto actualiza la informaciÃ³n de GitHub y te dirÃ¡ si tu rama estÃ¡ ahead (adelantada) o behind (atrasada).



ğŸ˜
Veamos cÃ³mo interpretar la salida de git status paso a paso
asÃ­ sabrÃ¡s exactamente quÃ© estÃ¡ pendiente entre tu copia local y GitHub.

---

## ğŸ” Ejemplo 1 â€” Todo estÃ¡ sincronizado

`On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean`

ğŸŸ¢ Significa:

ğŸ¥ EstÃ¡s en la rama main.

ğŸ¥ No hay cambios locales.

ğŸ¥ Todo lo que tienes en tu ordenador estÃ¡ igual que en GitHub.

âœ… No necesitas hacer nada.

---


## ğŸ” Ejemplo 2 â€” Hay cambios sin aÃ±adir

`On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
modified: archivoGit.md`

ğŸŸ¡ Significa:

ğŸ¥ Has modificado archivoGit.md.

ğŸ¥ Pero aÃºn no lo has aÃ±adido ni comiteado.

ğŸ‘‰ SoluciÃ³n:

`git add archivoGit.md
git commit -m "Describe tu cambio"`

---


## ğŸ” Ejemplo 3 â€” Hay commits locales sin subir a GitHub

`On branch main
Your branch is ahead of 'origin/main' by 1 commit.
(use "git push" to publish your local commits)

nothing to commit, working tree clean`

ğŸŸ  Significa:

ğŸ¥ Has hecho un commit local.

ğŸ¥ Pero aÃºn no lo has subido a GitHub.

ğŸ‘‰ SoluciÃ³n:

`git push`

---


## ğŸ” Ejemplo 4 â€” GitHub tiene commits que tÃº no tienes

`On branch main
Your branch is behind 'origin/main' by 2 commits, and can be fast-forwarded.
(use "git pull" to update your local branch)

nothing to commit, working tree clean`

ğŸ”µ Significa:

ğŸ¥ En GitHub hay 2 commits nuevos que tÃº todavÃ­a no tienes.

ğŸ¥ Tu repositorio local estÃ¡ desactualizado.

ğŸ‘‰ SoluciÃ³n:

`git pull`

---


## ğŸ” Ejemplo 5 â€” Tienes cambios locales sin subir y GitHub tiene otros distintos

`On branch main
Your branch and 'origin/main' have diverged,
and have 2 and 1 different commits each, respectively.
  (use "git pull" to merge the remote branch into yours)`

ğŸ”´ Significa:

ğŸ¥ Tanto tÃº como alguien mÃ¡s han hecho cambios en la misma rama.

ğŸ¥ Hay que sincronizar y resolver conflictos.

ğŸ‘‰ SoluciÃ³n:

`git pull`

# (si hay conflictos, los resuelves)

`git push`

## | FIN |

WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿ğŸŒ¿

ğŸ™‡â€â™‚ï¸ ğŸ™‡â€â™‚ï¸ ğŸ™‡â€â™‚ï¸ ğŸ™‡â€â™‚ï¸ ğŸ™‡â€â™‚ï¸ ğŸ™‡â€â™‚ï¸ ğŸ™‡â€â™‚ï¸ ğŸ™‡â€â™‚ï¸ ğŸ™‡â€â™‚ï¸ ğŸ™‡â€â™‚ï¸ ğŸ™‡â€â™‚ï¸ ğŸ™‡â€â™‚ï¸ ğŸ™‡â€â™‚ï¸ ğŸ™‡â€â™‚ï¸ ğŸ™‡â€â™‚ï¸ ğŸ™‡â€â™‚ï¸
I M P O R T A N T E

---

AquÃ­ tienes el flujo ideal de trabajo con Git y GitHub,
explicado paso a paso, con comandos y el por quÃ© de cada uno.

Este orden te asegura que:

ğŸ¥ Nunca pierdas cambios.

ğŸ¥ Mantengas tu repositorio limpio.

ğŸ¥ Evites conflictos con GitHub.

---

## ğŸ§­ FLUJO IDEAL DE TRABAJO CON GIT + GITHUB

ğŸª„ 1ï¸âƒ£ â€” Actualizar tu copia local antes de empezar a trabajar

Siempre antes de tocar nada, sincroniza tu repositorio local con GitHub:

`git pull origin main`

ğŸ“˜ Esto descarga los cambios mÃ¡s recientes del repositorio remoto (GitHub) y los aplica a tu copia local.
â¡ï¸ AsÃ­ evitas trabajar sobre una versiÃ³n desactualizada.



âœï¸ 2ï¸âƒ£ â€” Editar tus archivos

Haz los cambios que necesites en tu proyecto usando VS Code u otro editor.



ğŸ§© 3ï¸âƒ£ â€” Ver quÃ© cambiaste

Comprueba quÃ© archivos has modificado:

`git status`

Esto te muestra:

ğŸ¥ Archivos nuevos (untracked)

ğŸ¥ Archivos modificados (modified)

ğŸ¥ Archivos listos para comitear (staged)



ğŸ“¦ 4ï¸âƒ£ â€” AÃ±adir los cambios al Ã¡rea de preparaciÃ³n

Cuando estÃ©s listo para guardar tus cambios:

`git add .`

(. aÃ±ade todos los archivos modificados; si quieres aÃ±adir solo uno: git add nombreArchivo)



ğŸ“ 5ï¸âƒ£ â€” Crear un commit

Crea un commit con un mensaje claro:

`git commit -m "DescripciÃ³n breve del cambio"`

ğŸ’¡ Ejemplo:

`git commit -m "Actualizado archivoGit.md con ejemplos de git status"`

Esto guarda tus cambios localmente (pero aÃºn no estÃ¡n en GitHub).



â¬†ï¸ 6ï¸âƒ£ â€” Subir los cambios a GitHub

ğŸ›ï¸ğŸ›ï¸ EnvÃ­a tus commits al repositorio remoto: ğŸ›ï¸ğŸ›ï¸

`git push origin main`

ğŸ“¤ Ahora tus cambios estÃ¡n en GitHub y disponibles para todos los colaboradores.



ğŸ”„ 7ï¸âƒ£ â€” (Opcional) Revisa el estado de sincronizaciÃ³n

DespuÃ©s de subir:

`git status`

DeberÃ­as ver:

`Your branch is up to date with 'origin/main'.`

âœ… Eso significa que tu repositorio local y GitHub estÃ¡n sincronizados.

---


## ğŸ’¡ RESUMEN VISUAL RÃPIDO

## AcciÃ³n                                       Comando                         CuÃ¡ndo usar
============================================================================================================

Actualizar desde GitHub................. ```git pull origin main``` ............Antes de empezar a trabajar

Ver cambios............................. ```git status``` ......................Durante o antes de comitear

Preparar archivos....................... ```git add . ``` ......................Antes de hacer commit

Guardar cambios localmente.............. ```git commit -m "mensaje"``` .........Cuando termines un bloque de trabajo

## Subir a GitHub....................... ```git push origin main``` ............Cuando quieras actualizar el remoto


ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ ğŸ‘ The End.
